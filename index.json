[{"content":"프로그램(Program) 컴퓨터에서 실행될 때 특정 작업을 수행하는 일련의 명령어들의 집합이다. 특정 문제를 해결하기 위해 처리 방법과 순서를 기술하여 컴퓨터에 입력되는 일련의 명령문 집합체이며 대부분의 프로그램은 실행 중(즉, 명령어를 \u0026lsquo;불러들일\u0026rsquo; 때)에 사용자의 입력에 반응하도록 구현된 일련의 명령어들로 구성되어 있다. 대부분의 프로그램들은 하드디스크 등의 매체에 바이너리 형식의 파일로 저장되어 있다가 사용자가 실행시키면 메모리로 적재되어 실행된다.\n프로세스(Process) 컴퓨터에서 실행 중인 프로그램으로써 메모리 상에서 실행되는 작업 단위를 지칭한다. 각 프로세스 별로 독립된 메모리 공간을 할당 받으며, Code, Data, Heap, Stack 구조로 이루어져있다.\nPCB(Process Control Block) Process Control Block in OS - GeeksforGeeks\n프로세스가 시스템에 존재하는 동안 운영체제에서 프로세스를 용이하게 관리하기 위하여 프로세스의 메타데이터를 담고 있는 PCB(Process Control Block)이라는 자료구조를 저장하며, 프로세스의 생성과 삭제가 자주 일어나기 때문에 Linked List 형태로 관리된다. 일반 사용자가 접근하지 못하도록 항상 메모리 영역 내에 있으며, 커널 스택의 처음에 위치한다.\nPCB(Process Control Block) 구조 Process Control Block in OS - GeeksforGeeks\nPCB는 포인터(Pointer), PID(Process ID), 프로세스 상태(Process Status), 프로그램 카운터(Program Counter), 레지스터(Register)와 메모리 관리 정보(페이지 테이블 등), 우선순위 등을 포함한다. 각각의 항목에 들어가는 내용은 아래와 같다.\n항목 내용 PID 프로세스 구분하기 위한 고유 식별자 Procss State 프로세스의 현재 상태를 나타내며, Ready, Running, Blocked 등의 상태를 포함한다. Program Counter 다음에 수행할 명령어의 주소를 담고 있다. CPU Register 프로세스가 실행될 때 사용하는 CPU의 레지스터 값이다. 프로세스 전환시 저장되고 복원된다. Memory Information 프로세스가 사용하는 메모리 정보로, 페이지 테이블, 할당된 메모리 블록 등이 포함된다. Owner 프로세스의 소유자 정보를 나타내며, 일반적으로 사용자 ID가 저장된다. Process Scheduling Information 프로세스의 우선순위 및 스케줄링 관련 정보 Other Info 프로세스의 자원 분배 프로세스는 시스템 자원을 할당 받기 위하여 CPU는 한 번에 하나의 프로세스만 수행할 수 있기 때문에 멀티 태스킹을 위해서는 CPU 자원을 요구하는 프로세스들에게 시분할 방식으로 CPU 자원을 적절히 분배하여 거의 동시에 실행되게 하게 끔 하는 것이 중요하다.\n이를 위해 운영체제는 시스템 자원 소요 시간을 적절히 나누어 CPU 사용 시간을 분배한다. 이러한 정책을 **CPU 스케줄링(CPU Scheduling)**이라고 하는데, 이 작업을 수행하기 위하여 프로세스는 **상태(Status)**라는 값을 가지며, 운영체제는 프로세스의 상태 데이터와 우선 순위, 대기 시간, 응답 시간 등을 고려하여 시스템 자원을 분배한다.\nCPU 스케줄링(CPU Scheduling) CPU는 실행 중인 프로세스가 없을 경우 Ready Queue에 있는 프로세스를 하나 선택하여 실행해야 한다. 이때, Ready Queue에서 프로세스를 선택하는 방법은 CPU Scheduler에 의해 수행된다.\nCPU 스케줄링은 공평성, 효율성, 안정성 등을 보장해야 하며, Interrupt, I/O 작업이나 이벤트 대기 등 프로세스의 상태가 변화하는 상황이 발생할 때, CPU 스케줄링이 발생한다.\n프로세스의 상태 프로세스가 지니는 상태(Status)는 프로세스의 현재 상황을 나타낸다. 프로세스는 다양한 상태를 가질 수 있으며, 각 상태는 프로세스가 어떤 작업을 수행하고 있는 지를 나타낸다.\n상태 내용 Created - 생성 프로세스가 생성된 상태 Ready - 준비 프로세스가 메모리에 로드되어 CPU 자원의 할당을 기다리는 상태 Running - 실행 프로세스에 CPU 자원이 할당되어 CPU가 해당 프로세스를 실행 중인 상태 Terminated - 종료 프로세스가 실행이 완료되고 종료되어 CPU 자원이 다시 시스템에 반환된 상태 Blocked - 대기 프로세스가 필요한 자원(I/O 작업 등)을 기다리고 있는 상태 문맥교환(Context Switching) Context Switching in Operating System - GeeksforGeeks\nContext Switching은 CPU가 여러 프로세스를 처리할 때 이루어지는 과정으로, 현재까지의 프로세스 상태를 저장하고, 새로운 프로세스의 저장된 상태를 다시 적재하는 과정이다.\n요청 : 시스템 인터럽트, 트랩 등 Context Switching을 요청 PCB 저장 : 현재 작업 중인 프로세스(Process P0)의 정보를 현재 PCB에 저장 CPU 할당 : 다음 프로세스(Process P1)의 PCB 정보를 불러와 CPU를 할당 ","permalink":"https://ye0ngjae.blog/blog/2024-06-31-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B4%80%EB%A6%AC/","summary":"프로그램(Program) 컴퓨터에서 실행될 때 특정 작업을 수행하는 일련의 명령어들의 집합이다. 특정 문제를 해결하기 위해 처리 방법과 순서를 기술하여 컴퓨터에 입력되는 일련의 명령문 집합체이며 대부분의 프로그램은 실행 중(즉, 명령어를 \u0026lsquo;불러들일\u0026rsquo; 때)에 사용자의 입력에 반응하도록 구현된 일련의 명령어들로 구성되어 있다. 대부분의 프로그램들은 하드디스크 등의 매체에 바이너리 형식의 파일로 저장되어 있다가 사용자가 실행시키면 메모리로 적재되어 실행된다.\n프로세스(Process) 컴퓨터에서 실행 중인 프로그램으로써 메모리 상에서 실행되는 작업 단위를 지칭한다. 각 프로세스 별로 독립된 메모리 공간을 할당 받으며, Code, Data, Heap, Stack 구조로 이루어져있다.","title":"[OS] 프로세스(Process) 관리"},{"content":"MVC 아키텍처 MVC (Model-View-Controller)는 사용자 인터페이스를 개발할 때 자주 사용되는 디자인 패턴으로, 애플리케이션을 세 가지 상호 연결된 컴포넌트로 나눈다.\n모델 (Model) 모델 컴포넌트는 사용자가 작업하는 모든 데이터 관련 로직에 해당한다. 이는 뷰와 컨트롤러 컴포넌트 간에 전송되는 데이터나 기타 비즈니스 로직 관련 데이터를 나타낼 수 있다.\n예시: 고객 객체는 데이터베이스에서 고객 정보를 검색하고, 이를 조작하여 다시 데이터베이스에 업데이트하거나 데이터를 렌더링하는 데 사용한다.\n뷰 (View) 뷰 컴포넌트는 애플리케이션의 모든 UI 로직에 사용된다. 이는 모델에 포함된 데이터의 시각화를 나타낸다.\n예시: 고객 뷰는 최종 사용자가 상호작용하는 텍스트 상자, 드롭다운 등 모든 UI 구성 요소를 포함한다.\n컨트롤러 (Controller) 컨트롤러 컴포넌트는 모델과 뷰 컴포넌트 사이의 인터페이스 역할을 하여 모든 비즈니스 로직과 들어오는 요청을 처리하고, 모델 컴포넌트를 사용하여 데이터를 조작하며, 뷰와 상호작용하여 최종 출력을 렌더링한다.\n예시: 고객 컨트롤러는 고객 뷰의 입력을 처리하고, 고객 모델을 사용하여 데이터베이스를 업데이트한다.\nMVC 아키텍처의 장점 관심사의 분리: 애플리케이션은 정보의 내부 표현을 사용자에게 제시하고 받아들이는 방식과 분리된 세 가지 상호 연결된 컴포넌트로 나뉜다. 병렬 개발 용이: 여러 개발자가 모델, 뷰, 컨트롤러에서 동시에 작업할 수 있다. 유지 관리 용이: 관심사의 분리로 인해 관리와 유지보수가 더 쉽다. 확장성: 비즈니스 요구가 증가함에 따라 서비스의 확장이 용이하다. ","permalink":"https://ye0ngjae.blog/blog/2024-08-21-mvcarchitecture/","summary":"MVC 아키텍처 MVC (Model-View-Controller)는 사용자 인터페이스를 개발할 때 자주 사용되는 디자인 패턴으로, 애플리케이션을 세 가지 상호 연결된 컴포넌트로 나눈다.\n모델 (Model) 모델 컴포넌트는 사용자가 작업하는 모든 데이터 관련 로직에 해당한다. 이는 뷰와 컨트롤러 컴포넌트 간에 전송되는 데이터나 기타 비즈니스 로직 관련 데이터를 나타낼 수 있다.\n예시: 고객 객체는 데이터베이스에서 고객 정보를 검색하고, 이를 조작하여 다시 데이터베이스에 업데이트하거나 데이터를 렌더링하는 데 사용한다.\n뷰 (View) 뷰 컴포넌트는 애플리케이션의 모든 UI 로직에 사용된다. 이는 모델에 포함된 데이터의 시각화를 나타낸다.","title":"[Architecture] MVC Architecture"},{"content":"Layered Architecture 소프트웨어 시스템을 여러 계층으로 나누어 구성하는 아키텍처 스타일이다. 3 계층 구조(3 Tier Architecture)가 대표적이며, 표현 계층, 애플리케이션 계층, 데이터 계층으로 나뉜다.시스템의 모듈화와 유지 보수성을 높이기 위해 사용된다.\n3 계층 구조의 구성 요소 표현 계층(Presentation Layer) 사용자와 직접 상호 작용하는 계층으로, 사용자 인터페이스를 담당한다. 정보를 표시하고 사용자 입력을 받아들인다. 애플리케이션 계층(Application Layer) / 서비스의 주 로직이 구현되어 있는 계층이다. 비즈니스 로직을 처리하고 요청을 조정한다. 데이터 계층(Data Layer) 데이터베이스와 상호 작용하는 계층이다. 데이터 저장, 검색, 업데이트 등의 작업을 수행한다. Multitier Architecture Layered Architecture의 한 형태로 볼 수 있으며, 논리적 계층을 물리적 티어로 분리하여 구현하는 아키텍처 스타일이다. 이는 시스템의 배포 유연성을 높이고, 특정 계층의 부하를 분산시킬 수 있다.\nLayer(계층)와 Tier(티어)의 차이 Tier 티어는 시스템의 물리적 분리를 나타내며, 물리적으로 각각의 티어가 구분되어 있는 형태이다. 주로 서비스의 배포와 관련이 있으며, 서로 다른 물리적 장치 혹은 서버에 배포될 수 있는 시스템의 독립적인 구성을 의미한다.\nLayer 레이어 시스템의 논리적 분리를 나타내며, 주로 소프트웨어의 구조와 관련이 있다. 레이어 같은 애플리케이션 내에서 서로 다른 책임을 가진 모듈이나 컴포넌트를 구분하는 데 사용된다.\nN-tier Architecture 다중 계층 아키텍처로 불리며, 둘 이상의 계층을 가지는 모든 아키텍처를 말한다. 일반적으로 3 계층 아키텍처를 사용하며, 4 계층 이상부터는 시스템의 유지 보수의 어려움, 속도 저하 등의 문제 등으로 별로 사용하지 않는다.\n장점 Layered Architecture의 장점 모듈화: 각 레이어가 독립적으로 개발되고 유지보수될 수 있다. 유지보수성: 코드의 가독성과 유지보수성이 높아진다. 재사용성: 특정 레이어는 다른 애플리케이션에서도 재사용될 수 있다. 분리된 관심사: 각 레이어는 특정한 기능이나 책임을 가지므로, 역할이 명확하게 분리된다. Multitier Architecture의 장점 확장성: 특정 티어에 부하가 집중될 경우 해당 티어의 서버를 추가하여 확장할 수 있다. 유연한 배포: 각 티어를 독립적으로 배포하고 관리할 수 있다. 보안: 각 티어 간의 통신을 제어하여 보안을 강화할 수 있다. 장애 격리: 한 티어에 문제가 발생해도 다른 티어에 영향을 최소화할 수 있다. 레퍼런스 https://www.ibm.com/kr-ko/topics/three-tier-architecture https://velog.io/@yyy96/Architecture https://xxeol.tistory.com/26 ","permalink":"https://ye0ngjae.blog/blog/2024-08-20-ntierarchitecture/","summary":"Layered Architecture 소프트웨어 시스템을 여러 계층으로 나누어 구성하는 아키텍처 스타일이다. 3 계층 구조(3 Tier Architecture)가 대표적이며, 표현 계층, 애플리케이션 계층, 데이터 계층으로 나뉜다.시스템의 모듈화와 유지 보수성을 높이기 위해 사용된다.\n3 계층 구조의 구성 요소 표현 계층(Presentation Layer) 사용자와 직접 상호 작용하는 계층으로, 사용자 인터페이스를 담당한다. 정보를 표시하고 사용자 입력을 받아들인다. 애플리케이션 계층(Application Layer) / 서비스의 주 로직이 구현되어 있는 계층이다. 비즈니스 로직을 처리하고 요청을 조정한다. 데이터 계층(Data Layer) 데이터베이스와 상호 작용하는 계층이다.","title":"[Architecture] Layered \u0026 Multitier Architecture"},{"content":"DB에서의 사용자 권한 관리 DB에서의 사용자 관리는 데이터베이스의 보안과 운영에 중요한 역할을 한다. 적절한 권한 관리를 통하여 데이터의 무결성을 유지하고, 불필요한 접근을 제한할 수 있다.\nDB를 처음 설치하고 접속할 경우 기본적으로 주어지는 계정은 root 계정이기 때문에, 이를 그대로 서비스 운영에 사용하는 것은 보안상 매우 위험한 선택이 될 수 있다. 따라서, 개발자는 서비스 별로 적절한 권한을 가진 사용자를 생성하여 사용하는 것이 보안적인 측면에서 바람직하다.\n사용자 생성 권한을 부여하기에 앞서 사용자를 생성해야 한다. 사용자를 생성하는 방법은 다음과 같다.\nCREATE USER \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39; IDENTIFIED BY \u0026#39;비밀번호\u0026#39;; 사용자명: 사용자명 호스트: 접속을 허용할 호스트 비밀번호: 비밀번호 기본적인 구성은 위와 같으며, 사용자명과 호스트는 필수로 입력해야 한다. 비밀번호는 선택적으로 입력할 수 있다. 만약 비밀번호를 입력하지 않을 경우, 사용자 생성 후에 비밀번호를 설정할 수 있다.\n#ex1) 내부 접근을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;0000\u0026#39;; #ex2) 외부 접근을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;0000\u0026#39;; #ex3) 특정 ip만 접근을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;123.456.789.100\u0026#39; identified by \u0026#39;0000\u0026#39;; #ex4) 특정 ip 대역을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;192.168.%\u0026#39; identified by \u0026#39;0000\u0026#39;; 위는 사용자를 생성하는 예시이다.\n사용자 삭제 위 방법으로 생성한 사용자를 삭제하는 명령어는 다음과 같다.\nDROP USER \u0026#39;사용자명\u0026#39;; # 혹은 DROP USER \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 사용자명: 사용자명 호스트: 접속을 허용한 호스트 권한 부여 사용자에게 권한을 부여하는 방법은 다음과 같다.\nGRANT \u0026#39;권한\u0026#39; ON \u0026#39;데이터베이스.테이블\u0026#39; TO \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 권한: 사용자에게 부여할 권한(SELECT,INSERT,UPDATE,DELETE 등) 데이터베이스: 권한을 부여할 데이터베이스 테이블: 권한을 부여할 테이블 사용자명: 권한을 부여할 사용자 호스트: 권한을 부여할 호스트 # 모든 데이터베이스의 모든 테이블에 모든 권한을 줌 grant all privileges on *.* to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 모든 테이블에 모든 권한을 줌 grant all privileges on \u0026#39;DB이름\u0026#39;.* to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 모든 권한을 줌 grant all privileges on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 select 권한을 줌 grant select on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 select, insert 권한을 줌 grant select, insert on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블의 컬럼1과 컬럼2의 update 권한을 줌 grant update(\u0026#39;컬럼1\u0026#39;, \u0026#39;컬럼2\u0026#39;) on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; 권한 취소 만일 사용자에게 부여해야 하는 권한보다 더 많은 권한을 부여했을 경우, 권한을 취소할 수 있다.\nREVOKE \u0026#39;권한\u0026#39; ON \u0026#39;데이터베이스.테이블\u0026#39; FROM \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 권한: 취소할 권한 데이터베이스: 권한을 취소할 데이터베이스 테이블: 권한을 취소할 테이블 사용자명: 권한을 취소할 사용자 호스트: 권한을 취소할 호스트 # 모든 데이터베이스의 모든 테이블에 대한 모든 권한을 회수 revoke all privileges on *.* from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 모든 테이블에 대한 모든 권한을 회수 revoke all privileges on \u0026#39;DB이름\u0026#39;.* from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 대한 모든 권한을 회수 revoke all privileges on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 대한 select 권한을 회수 revoke select on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 대한 select, insert 권한을 회수 revoke select, insert on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블의 컬럼1과 컬럼2에 대한 update 권한을 회수 revoke update(\u0026#39;컬럼1\u0026#39;, \u0026#39;컬럼2\u0026#39;) on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; 권한 확인 사용자에게 부여된 권한을 확인하는 방법은 다음과 같다.\nSHOW GRANTS FOR \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 사용자명: 권한을 확인할 사용자 호스트: 권한을 확인할 호스트 DB 반영 권한을 부여하거나 취소한 후에는 FLUSH PRIVILEGES; 명령어를 통해 변경사항을 DB에 반영해야 한다.\nFLUSH PRIVILEGES; ","permalink":"https://ye0ngjae.blog/blog/2024-08-20-db%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B6%8C%ED%95%9C%EA%B4%80%EB%A6%AC/","summary":"DB에서의 사용자 권한 관리 DB에서의 사용자 관리는 데이터베이스의 보안과 운영에 중요한 역할을 한다. 적절한 권한 관리를 통하여 데이터의 무결성을 유지하고, 불필요한 접근을 제한할 수 있다.\nDB를 처음 설치하고 접속할 경우 기본적으로 주어지는 계정은 root 계정이기 때문에, 이를 그대로 서비스 운영에 사용하는 것은 보안상 매우 위험한 선택이 될 수 있다. 따라서, 개발자는 서비스 별로 적절한 권한을 가진 사용자를 생성하여 사용하는 것이 보안적인 측면에서 바람직하다.\n사용자 생성 권한을 부여하기에 앞서 사용자를 생성해야 한다.","title":"[SQL] DB에서의 사용자 권한 관리"},{"content":"Profile 남영재 / 2006.03.25\nOrganization Sunrin Internet High School InfoSec 117th Layer7 Hacking Club Activity 서울여자대학교 정보보호영재교육원 8기(2021.03 ~ 2021.12) 서울여자대학교 정보보호영재교육원 9기(2022.03 ~ 2022.12) 개인정보보호위원회 청소년개인정보보호리더 1기(2022.05 ~ 2022.12) Award 2024\n2024 POSCO AI Youth Challenge 장려상 2024 D-Camp 청소년 창업경진대회 최우수상 2023\n선린인터넷고등학교 교내 창의아이디어 경진대회 대상 2022\n2022 임베디드 소프트웨어 경진대회 우수상 서울여자대학교 정보보호영재교육원 정보보안 경진대회 우수상 선린인터넷고등학교 교내 LogCon CTF 동상 선린인터넷고등학교 교내 디지털콘텐츠디자인대회 우수상 선린인터넷고등학교 교내 고등해커 CTF 은상 2021\n2021 인천 학생 해커톤 인천광역시교육감상 2020\n한세사이버보안고등학교 중학생 정보보안 콘테스트 동상 2020 학생 창의력 챔피언 대회 은상 ","permalink":"https://ye0ngjae.blog/about/","summary":"About me","title":"About me"}]