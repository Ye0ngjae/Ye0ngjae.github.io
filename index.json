[{"content":"MVC 아키텍처 MVC (Model-View-Controller)는 사용자 인터페이스를 개발할 때 자주 사용되는 디자인 패턴으로, 애플리케이션을 세 가지 상호 연결된 컴포넌트로 나눈다.\n모델 (Model) 모델 컴포넌트는 사용자가 작업하는 모든 데이터 관련 로직에 해당한다. 이는 뷰와 컨트롤러 컴포넌트 간에 전송되는 데이터나 기타 비즈니스 로직 관련 데이터를 나타낼 수 있다.\n예시: 고객 객체는 데이터베이스에서 고객 정보를 검색하고, 이를 조작하여 다시 데이터베이스에 업데이트하거나 데이터를 렌더링하는 데 사용한다.\n뷰 (View) 뷰 컴포넌트는 애플리케이션의 모든 UI 로직에 사용된다. 이는 모델에 포함된 데이터의 시각화를 나타낸다.\n예시: 고객 뷰는 최종 사용자가 상호작용하는 텍스트 상자, 드롭다운 등 모든 UI 구성 요소를 포함한다.\n컨트롤러 (Controller) 컨트롤러 컴포넌트는 모델과 뷰 컴포넌트 사이의 인터페이스 역할을 하여 모든 비즈니스 로직과 들어오는 요청을 처리하고, 모델 컴포넌트를 사용하여 데이터를 조작하며, 뷰와 상호작용하여 최종 출력을 렌더링한다.\n예시: 고객 컨트롤러는 고객 뷰의 입력을 처리하고, 고객 모델을 사용하여 데이터베이스를 업데이트한다.\nMVC 아키텍처의 장점 관심사의 분리: 애플리케이션은 정보의 내부 표현을 사용자에게 제시하고 받아들이는 방식과 분리된 세 가지 상호 연결된 컴포넌트로 나뉜다. 병렬 개발 용이: 여러 개발자가 모델, 뷰, 컨트롤러에서 동시에 작업할 수 있다. 유지 관리 용이: 관심사의 분리로 인해 관리와 유지보수가 더 쉽다. 확장성: 비즈니스 요구가 증가함에 따라 서비스의 확장이 용이하다. ","permalink":"https://ye0ngjae.blog/blog/2024-08-21-mvcarchitecture/","summary":"MVC 아키텍처 MVC (Model-View-Controller)는 사용자 인터페이스를 개발할 때 자주 사용되는 디자인 패턴으로, 애플리케이션을 세 가지 상호 연결된 컴포넌트로 나눈다.\n모델 (Model) 모델 컴포넌트는 사용자가 작업하는 모든 데이터 관련 로직에 해당한다. 이는 뷰와 컨트롤러 컴포넌트 간에 전송되는 데이터나 기타 비즈니스 로직 관련 데이터를 나타낼 수 있다.\n예시: 고객 객체는 데이터베이스에서 고객 정보를 검색하고, 이를 조작하여 다시 데이터베이스에 업데이트하거나 데이터를 렌더링하는 데 사용한다.\n뷰 (View) 뷰 컴포넌트는 애플리케이션의 모든 UI 로직에 사용된다. 이는 모델에 포함된 데이터의 시각화를 나타낸다.","title":"[Architecture] MVC Architecture"},{"content":"Layered Architecture 소프트웨어 시스템을 여러 계층으로 나누어 구성하는 아키텍처 스타일이다. 3 계층 구조(3 Tier Architecture)가 대표적이며, 표현 계층, 애플리케이션 계층, 데이터 계층으로 나뉜다.시스템의 모듈화와 유지 보수성을 높이기 위해 사용된다.\n3 계층 구조의 구성 요소 표현 계층(Presentation Layer) 사용자와 직접 상호 작용하는 계층으로, 사용자 인터페이스를 담당한다. 정보를 표시하고 사용자 입력을 받아들인다. 애플리케이션 계층(Application Layer) / 서비스의 주 로직이 구현되어 있는 계층이다. 비즈니스 로직을 처리하고 요청을 조정한다. 데이터 계층(Data Layer) 데이터베이스와 상호 작용하는 계층이다. 데이터 저장, 검색, 업데이트 등의 작업을 수행한다. Multitier Architecture Layered Architecture의 한 형태로 볼 수 있으며, 논리적 계층을 물리적 티어로 분리하여 구현하는 아키텍처 스타일이다. 이는 시스템의 배포 유연성을 높이고, 특정 계층의 부하를 분산시킬 수 있다.\nLayer(계층)와 Tier(티어)의 차이 Tier 티어는 시스템의 물리적 분리를 나타내며, 물리적으로 각각의 티어가 구분되어 있는 형태이다. 주로 서비스의 배포와 관련이 있으며, 서로 다른 물리적 장치 혹은 서버에 배포될 수 있는 시스템의 독립적인 구성을 의미한다.\nLayer 레이어 시스템의 논리적 분리를 나타내며, 주로 소프트웨어의 구조와 관련이 있다. 레이어 같은 애플리케이션 내에서 서로 다른 책임을 가진 모듈이나 컴포넌트를 구분하는 데 사용된다.\nN-tier Architecture 다중 계층 아키텍처로 불리며, 둘 이상의 계층을 가지는 모든 아키텍처를 말한다. 일반적으로 3 계층 아키텍처를 사용하며, 4 계층 이상부터는 시스템의 유지 보수의 어려움, 속도 저하 등의 문제 등으로 별로 사용하지 않는다.\n장점 Layered Architecture의 장점 모듈화: 각 레이어가 독립적으로 개발되고 유지보수될 수 있다. 유지보수성: 코드의 가독성과 유지보수성이 높아진다. 재사용성: 특정 레이어는 다른 애플리케이션에서도 재사용될 수 있다. 분리된 관심사: 각 레이어는 특정한 기능이나 책임을 가지므로, 역할이 명확하게 분리된다. Multitier Architecture의 장점 확장성: 특정 티어에 부하가 집중될 경우 해당 티어의 서버를 추가하여 확장할 수 있다. 유연한 배포: 각 티어를 독립적으로 배포하고 관리할 수 있다. 보안: 각 티어 간의 통신을 제어하여 보안을 강화할 수 있다. 장애 격리: 한 티어에 문제가 발생해도 다른 티어에 영향을 최소화할 수 있다. 레퍼런스 https://www.ibm.com/kr-ko/topics/three-tier-architecture https://velog.io/@yyy96/Architecture https://xxeol.tistory.com/26 ","permalink":"https://ye0ngjae.blog/blog/2024-08-20-ntierarchitecture/","summary":"Layered Architecture 소프트웨어 시스템을 여러 계층으로 나누어 구성하는 아키텍처 스타일이다. 3 계층 구조(3 Tier Architecture)가 대표적이며, 표현 계층, 애플리케이션 계층, 데이터 계층으로 나뉜다.시스템의 모듈화와 유지 보수성을 높이기 위해 사용된다.\n3 계층 구조의 구성 요소 표현 계층(Presentation Layer) 사용자와 직접 상호 작용하는 계층으로, 사용자 인터페이스를 담당한다. 정보를 표시하고 사용자 입력을 받아들인다. 애플리케이션 계층(Application Layer) / 서비스의 주 로직이 구현되어 있는 계층이다. 비즈니스 로직을 처리하고 요청을 조정한다. 데이터 계층(Data Layer) 데이터베이스와 상호 작용하는 계층이다.","title":"[Architecture] Layered \u0026 Multitier Architecture"},{"content":"DB에서의 사용자 권한 관리 DB에서의 사용자 관리는 데이터베이스의 보안과 운영에 중요한 역할을 한다. 적절한 권한 관리를 통하여 데이터의 무결성을 유지하고, 불필요한 접근을 제한할 수 있다.\nDB를 처음 설치하고 접속할 경우 기본적으로 주어지는 계정은 root 계정이기 때문에, 이를 그대로 서비스 운영에 사용하는 것은 보안상 매우 위험한 선택이 될 수 있다. 따라서, 개발자는 서비스 별로 적절한 권한을 가진 사용자를 생성하여 사용하는 것이 보안적인 측면에서 바람직하다.\n사용자 생성 권한을 부여하기에 앞서 사용자를 생성해야 한다. 사용자를 생성하는 방법은 다음과 같다.\nCREATE USER \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39; IDENTIFIED BY \u0026#39;비밀번호\u0026#39;; 사용자명: 사용자명 호스트: 접속을 허용할 호스트 비밀번호: 비밀번호 기본적인 구성은 위와 같으며, 사용자명과 호스트는 필수로 입력해야 한다. 비밀번호는 선택적으로 입력할 수 있다. 만약 비밀번호를 입력하지 않을 경우, 사용자 생성 후에 비밀번호를 설정할 수 있다.\n#ex1) 내부 접근을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;0000\u0026#39;; #ex2) 외부 접근을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;0000\u0026#39;; #ex3) 특정 ip만 접근을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;123.456.789.100\u0026#39; identified by \u0026#39;0000\u0026#39;; #ex4) 특정 ip 대역을 허용하는 사용자 추가 create user \u0026#39;test\u0026#39;@\u0026#39;192.168.%\u0026#39; identified by \u0026#39;0000\u0026#39;; 위는 사용자를 생성하는 예시이다.\n사용자 삭제 위 방법으로 생성한 사용자를 삭제하는 명령어는 다음과 같다.\nDROP USER \u0026#39;사용자명\u0026#39;; # 혹은 DROP USER \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 사용자명: 사용자명 호스트: 접속을 허용한 호스트 권한 부여 사용자에게 권한을 부여하는 방법은 다음과 같다.\nGRANT \u0026#39;권한\u0026#39; ON \u0026#39;데이터베이스.테이블\u0026#39; TO \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 권한: 사용자에게 부여할 권한(SELECT,INSERT,UPDATE,DELETE 등) 데이터베이스: 권한을 부여할 데이터베이스 테이블: 권한을 부여할 테이블 사용자명: 권한을 부여할 사용자 호스트: 권한을 부여할 호스트 # 모든 데이터베이스의 모든 테이블에 모든 권한을 줌 grant all privileges on *.* to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 모든 테이블에 모든 권한을 줌 grant all privileges on \u0026#39;DB이름\u0026#39;.* to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 모든 권한을 줌 grant all privileges on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 select 권한을 줌 grant select on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 select, insert 권한을 줌 grant select, insert on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블의 컬럼1과 컬럼2의 update 권한을 줌 grant update(\u0026#39;컬럼1\u0026#39;, \u0026#39;컬럼2\u0026#39;) on \u0026#39;DB이름.테이블명\u0026#39; to \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; 권한 취소 만일 사용자에게 부여해야 하는 권한보다 더 많은 권한을 부여했을 경우, 권한을 취소할 수 있다.\nREVOKE \u0026#39;권한\u0026#39; ON \u0026#39;데이터베이스.테이블\u0026#39; FROM \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 권한: 취소할 권한 데이터베이스: 권한을 취소할 데이터베이스 테이블: 권한을 취소할 테이블 사용자명: 권한을 취소할 사용자 호스트: 권한을 취소할 호스트 # 모든 데이터베이스의 모든 테이블에 대한 모든 권한을 회수 revoke all privileges on *.* from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 모든 테이블에 대한 모든 권한을 회수 revoke all privileges on \u0026#39;DB이름\u0026#39;.* from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 대한 모든 권한을 회수 revoke all privileges on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 대한 select 권한을 회수 revoke select on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블에 대한 select, insert 권한을 회수 revoke select, insert on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; # 특정 데이터베이스의 특정 테이블의 컬럼1과 컬럼2에 대한 update 권한을 회수 revoke update(\u0026#39;컬럼1\u0026#39;, \u0026#39;컬럼2\u0026#39;) on \u0026#39;DB이름.테이블명\u0026#39; from \u0026#39;사용자\u0026#39;@\u0026#39;localhost\u0026#39;; 권한 확인 사용자에게 부여된 권한을 확인하는 방법은 다음과 같다.\nSHOW GRANTS FOR \u0026#39;사용자명\u0026#39;@\u0026#39;호스트\u0026#39;; 사용자명: 권한을 확인할 사용자 호스트: 권한을 확인할 호스트 DB 반영 권한을 부여하거나 취소한 후에는 FLUSH PRIVILEGES; 명령어를 통해 변경사항을 DB에 반영해야 한다.\nFLUSH PRIVILEGES; ","permalink":"https://ye0ngjae.blog/blog/2024-08-20-db%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B6%8C%ED%95%9C%EA%B4%80%EB%A6%AC/","summary":"DB에서의 사용자 권한 관리 DB에서의 사용자 관리는 데이터베이스의 보안과 운영에 중요한 역할을 한다. 적절한 권한 관리를 통하여 데이터의 무결성을 유지하고, 불필요한 접근을 제한할 수 있다.\nDB를 처음 설치하고 접속할 경우 기본적으로 주어지는 계정은 root 계정이기 때문에, 이를 그대로 서비스 운영에 사용하는 것은 보안상 매우 위험한 선택이 될 수 있다. 따라서, 개발자는 서비스 별로 적절한 권한을 가진 사용자를 생성하여 사용하는 것이 보안적인 측면에서 바람직하다.\n사용자 생성 권한을 부여하기에 앞서 사용자를 생성해야 한다.","title":"[SQL] DB에서의 사용자 권한 관리"},{"content":"문제 절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.\n배열에 정수 x (x ≠ 0)를 넣는다. 배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다. 프로그램은 처음에 비어있는 배열에서 시작하게 된다. 입력 첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 $$ -2^31 $$보다 크고, $$ 2^31 $$보다 작다.\n출력 입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.\n예제 입력 1 18\r1\r-1\r0\r0\r0\r1\r1\r-1\r-1\r2\r-2\r0\r0\r0\r0\r0\r0\r0 예제 출력 1 -1\r1\r0\r-1\r-1\r1\r1\r-2\r2\r0 풀이 heapq 모듈을 사용하여 풀이한다. heapq 모듈은 최소 힙을 지원한다. 절대값을 기준으로 최소 힙을 구현하기 위해 (abs(x), x)를 힙에 넣는다. x가 0이면 힙이 비어있지 않다면 절대값이 가장 작은 값을 출력하고, 그 값을 힙에서 제거한다. x가 0이 아니면 (abs(x), x)를 힙에 넣는다. import heapq import sys heap = [] N = int(sys.stdin.readline().strip()) for _ in range(N): x = int(sys.stdin.readline().strip()) if x == 0: if heap: print(heapq.heappop(heap)[1]) else: print(0) else: heapq.heappush(heap, (abs(x), x)) ","permalink":"https://ye0ngjae.blog/blog/2024-06-28-%EC%A0%88%EB%8C%80%EA%B0%92%ED%9E%99/","summary":"문제 절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.\n배열에 정수 x (x ≠ 0)를 넣는다. 배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다. 프로그램은 처음에 비어있는 배열에서 시작하게 된다. 입력 첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다.","title":"[알고리즘] 백준 11286번 절대값 힙(Python)"},{"content":"문제 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.\n입력 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.\n출력 첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.\n예제 입력 1 11\r1 4\r3 5\r0 6\r5 7\r3 8\r5 9\r6 10\r8 11\r8 12\r2 13\r12 14 예제 출력 1 4 풀이 회의가 끝나는 시간을 기준으로 정렬한다. 회의가 끝나는 시간이 같다면 시작하는 시간을 기준으로 정렬한다. 회의가 끝나는 시간이 가장 빠른 회의부터 시작한다. 회의가 끝나는 시간이 같다면 시작하는 시간이 가장 빠른 회의부터 시작한다. 회의가 끝나는 시간이 같고 시작하는 시간이 같다면 회의 번호가 작은 회의부터 시작한다. import sys arr = [] count = 1 tmp = 0 T = int(sys.stdin.readline()) for i in range(T): a,b = map(int, sys.stdin.readline().split()) arr.append([a,b]) arr.sort(key=lambda x: (x[1], x[0])) tmp = arr[0][1] for i in range(1,T): if tmp \u0026lt;= arr[i][0]: count += 1 tmp = arr[i][1] else: continue print(count) ","permalink":"https://ye0ngjae.blog/blog/2024-06-28-%ED%9A%8C%EC%9D%98%EC%8B%A4%EB%B0%B0%EC%A0%95/","summary":"문제 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.\n입력 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다.","title":"[알고리즘] 백준 1931번 회의실 배정(Python)"},{"content":"Profile 남영재 / 2006.03.25\nOrganization Sunrin Internet High School InfoSec 117th Layer7 Hacking Club Activity 서울여자대학교 정보보호영재교육원 8기(2021.03 ~ 2021.12) 서울여자대학교 정보보호영재교육원 9기(2022.03 ~ 2022.12) 개인정보보호위원회 청소년개인정보보호리더 1기(2022.05 ~ 2022.12) Award 2024\n2024 D-Camp 청소년 창업경진대회 최우수상 2023\n선린인터넷고등학교 교내 창의아이디어 경진대회 대상 2022\n2022 임베디드 소프트웨어 경진대회 우수상 서울여자대학교 정보보호영재교육원 정보보안 경진대회 우수상 선린인터넷고등학교 교내 LogCon CTF 동상 선린인터넷고등학교 교내 디지털콘텐츠디자인대회 우수상 선린인터넷고등학교 교내 고등해커 CTF 은상 2021\n2021 인천 학생 해커톤 인천광역시교육감상 2020\n한세사이버보안고등학교 중학생 정보보안 콘테스트 동상 2020 학생 창의력 챔피언 대회 은상 ","permalink":"https://ye0ngjae.blog/about/","summary":"About me","title":"About me"}]